<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Конвертирование картинки для БК (png, gif) в ассемблерный код</title>
    <style type="text/css">
        * {
            font: 16px Helvetica, Arial, sans-serif;
        }

        [v-cloak] {
            display: none;
        }

        h1 {
            font-size: 1.3em;
        }

        #image {
            max-width: 300px;
            max-height: 300px;
        }

        #result {
            height: 300px;
            width: 1024px;
            font-family: monospace;
            box-sizing: border-box;
        }

        #resultImageRow {
            display: flex;
            align-items: flex-start;
        }

        #resultImageWrapper {
            flex-grow: 0;
            flex-shrink: 0;
            position: relative;
        }

        #resultImage canvas {
            display: block;
        }

        #cropper {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            border: 0 solid rgba(127, 127, 127, 0.8);
        }

        #cropperParams {
            margin-left: 10px;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .form-line {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 5px;
        }

        .form-line:first-child {
            margin-top: 5px;
        }

        .form-line label {
            margin-right: 10px;
        }

        .form-line input {
            width: 50px;
            text-align: right;
        }
    </style>

</head>
<body>
<h1>Конвертирование картинки для БК (png, gif) в ассемблерный код</h1>
<div id="app" v-cloak>
    <p><input type="file" @change="fileChanged"></p>
    <p v-show="showImage"><img id="image" ref="image"></p>
    <p v-if="error" style="color:red">{{ error }}</p>
    <div v-show="showImage && !error">
        <p v-if="mainPalette">
            Автоматически определена палитра
            {{ mainPalette }}<span v-if="alsoPalettes.length">,
            также {{ alsoPalettes.length > 1 ? 'подходят палитры' : 'подходит палитра' }}
            {{ alsoPalettes.join(', ') }}</span>
        </p>
        <p>
            Палитра:
            <select v-model="palette">
                <option v-for="(n, i) in 16">{{ (i < 10 ? '0' : '') + i }}</option>
            </select>
        </p>
        <p>
            <select v-model="outputType">
                <option>WORD</option>
                <option>BYTE</option>
            </select>
            <select v-model="radix">
                <option>2</option>
                <option>8</option>
                <option>10</option>
                <option>16</option>
            </select>
            <label>
                <input type="checkbox" v-model="insertSize">
                Добавить в начале размер картинки в {{ outputType === 'WORD' ? 'словах' : 'байтах' }} и строках
            </label>
        </p>
        <p>
            <button @click="convertFile">Сконвертировать</button>
        </p>
        <p>
            <textarea id="result" v-model="result" ref="result"></textarea><br>
            <button @click="copyResult">Скопировать</button>
        </p>
        <div id="resultImageRow">
            <div id="resultImageWrapper">
                <div id="resultImage" ref="resultImage"></div>
                <div id="cropper" v-bind:style="cropStyles" v-if="useCrop"></div>
            </div>
            <div id="cropperParams">
                <label><input type="checkbox" v-model="useCrop"> Обрезать</label>
                <div v-show="useCrop">
                    <div class="form-line">
                        <label for="cropX">Смещение по X, байт (4 пикселя):</label>
                        <input id="cropX" type="number" v-model.number="crop.x" maxlength="2" min="0"
                               v-bind:max="maxWidth"/>
                    </div>
                    <div class="form-line">
                        <label for="cropY">Смещение по Y, строк:</label>
                        <input id="cropY" type="number" v-model.number="crop.y" maxlength="3" min="0"
                               v-bind:max="maxHeight"/>
                    </div>
                    <div class="form-line">
                        <label for="cropWidth">Ширина, байт (4 пикселя):</label>
                        <input id="cropWidth" type="number" v-model.number="crop.width" maxlength="2" min="0"
                               v-bind:max="maxWidth"/>
                    </div>
                    <div class="form-line">
                        <label for="cropHeight">Высота, строк:</label>
                        <input id="cropHeight" type="number" v-model.number="crop.height" maxlength="3" min="0"
                               v-bind:max="maxHeight"/>
                    </div>
                    <div class="form-line">
                        <button @click="resetCrop">Сбросить</button>
                        <button @click="convertFile">Сконвертировать</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.min.js"></script>
<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>

<script>
  var PREVIEW_PIXEL_WIDTH = 4;
  var PREVIEW_PIXEL_HEIGHT = 3;
  var STORAGE_KEY_SETS = 'setsData';
  var STORAGE_KEY_CROP = 'cropData';
  var OUTPUT_BYTE = 'BYTE';
  var OUTPUT_WORD = 'WORD';
  var OUTPUT_TYPES = [OUTPUT_WORD, OUTPUT_BYTE];
  var RADIX_LIST = ['2', '8', '10', '16'];

  var PALETTES = [
    ['0000FF', '00FF00', 'FF0000'],
    ['FFFF00', 'FF00FF', 'FF0000'],
    ['00FFFF', '0000FF', 'FF00FF'],
    ['00FF00', '00FFFF', 'FFFF00'],
    ['FF00FF', '00FFFF', 'FFFFFF'],
    ['FFFFFF', 'FFFFFF', 'FFFFFF'],
    ['C00000', '900000', 'FF0000'],
    ['C0FF00', '90FF00', 'FFFF00'],
    ['C000FF', '9000FF', 'FF00FF'],
    ['90FF00', '9000FF', '900000'],
    ['C0FF00', 'C000FF', 'C00000'],
    ['00FFFF', 'FFFF00', 'FF0000'],
    ['FF0000', '00FF00', '00FFFF'],
    ['00FFFF', 'FFFF00', 'FFFFFF'],
    ['FFFF00', '00FF00', 'FFFFFF'],
    ['00FFFF', '00FF00', 'FFFFFF']
  ];

  var COLOR_DELTA = Math.round(256 * 0.05); // Допуск 5% для цветового компонента

  var app = new Vue({
    el: '#app',
    data: {
      palette: '00',
      outputType: OUTPUT_WORD,
      radix: '8',
      insertSize: true,
      error: '',
      showImage: false,
      matchedPalettes: null,
      result: '',
      imageSize: null,
      useCrop: false,
      crop: {
        x: 0,
        y: 0,
        width: 64,
        height: 256
      }
    },
    created: function() {
      var _this = this;
      var cropDataText = localStorage.getItem(STORAGE_KEY_CROP);
      if (cropDataText) {
        try {
          var cropData = JSON.parse(cropDataText);
          Object.keys(this.crop).forEach(function(field) {
            if (field in cropData) {
              _this.crop[field] = parseInt(cropData[field], 10) || 0;
            }
          });
        } catch (e) {}
      }
      var setsDataText = localStorage.getItem(STORAGE_KEY_SETS);
      if (setsDataText) {
        try {
          var setsData = JSON.parse(setsDataText);
          if (setsData.outputType && OUTPUT_TYPES.indexOf(setsData.outputType) > -1) {
            _this.outputType = setsData.outputType;
          }
          if (setsData.radix && RADIX_LIST.indexOf(setsData.radix) > -1) {
            _this.radix = setsData.radix;
          }
          if ('insertSize' in setsData) {
            _this.insertSize = !!setsData.insertSize;
          }
        } catch (e) {}
      }
    },
    computed: {
      mainPalette: function() {
        return Array.isArray(this.matchedPalettes) && this.matchedPalettes.length ?
            this.matchedPalettes[0] : null;
      },
      alsoPalettes: function() {
        return Array.isArray(this.matchedPalettes) ?
            this.matchedPalettes.slice(1) : [];
      },
      maxWidth: function() {
        return this.imageSize ? Math.ceil(this.imageSize.width / 4) : 0;
      },
      maxHeight: function() {
        return this.imageSize ? this.imageSize.height : 0;
      },
      cropCorrect: function() {
        var crop = this.crop;
        if (!this.imageSize) return crop;
        var x = getValue('x', this.maxWidth);
        var y = getValue('y', this.maxHeight);
        var width = getValue('width', this.maxWidth - x);
        var height = getValue('height', this.maxHeight - y);
        return {x: x, y: y, width: width, height: height};

        function getValue(field, max) {
          var value = parseInt(crop[field], 10);
          if (value < 0) value = 0;
          else if (value > max) value = max;
          return value;
        }
      },
      cropStyles: function() {
        if (!this.imageSize) return;
        var crop = this.cropCorrect;
        var imageWidth = this.imageSize.width;
        var right = imageWidth - (crop.x + crop.width) * 4;
        if (right < 0) right = 0;
        var bottom = this.maxHeight - crop.height - crop.y;
        var left = crop.x * 4;
        if (left > imageWidth) left = imageWidth;
        return {
          borderWidth: (crop.y * PREVIEW_PIXEL_HEIGHT) + 'px ' +
              (right * PREVIEW_PIXEL_WIDTH) + 'px ' +
              (bottom * PREVIEW_PIXEL_HEIGHT) + 'px ' +
              (left * PREVIEW_PIXEL_WIDTH) + 'px'
        };
      }
    },
    methods: {
      fileChanged: function(event) {
        this.error = '';
        this.showImage = false;
        this.matchedPalettes = null;
        this.converter = null;
        this.result = '';
        this.$refs.resultImage.innerHTML = '';
        this.useCrop = false;
        this.imageSize = null;
        this.lastPalette = null;
        var file = event.target.files[0];
        if (!file) return;
        var img = this.$refs.image;
        var _this = this;
        getConverterFromFile(file, img).then(function(result) {
          _this.showImage = true;
          if (result.error) {
            _this.error = result.error;
          } else {
            _this.matchedPalettes = result.converter.getMatchedPalettes();
            if (!_this.matchedPalettes.length) {
              _this.error = 'Не удалось определить палитру, это не подходящий для БК рисунок';
            } else {
              _this.converter = result.converter;
              _this.palette = _this.matchedPalettes[0];
              _this.imageSize = _this.converter.getSize();
              _this.crop = _this.cropCorrect;
              _this.convertFile();
            }
          }
        });
      },

      convertFile: function() {
        var paletteId = +this.palette;
        if (this.useCrop) {
          this.crop = this.cropCorrect;
          localStorage.setItem(STORAGE_KEY_CROP, JSON.stringify(this.crop));
        }
        localStorage.setItem(STORAGE_KEY_SETS, JSON.stringify({
          outputType: this.outputType,
          radix: this.radix,
          insertSize: this.insertSize
        }));
        this.result = this.converter.getSourceText(
            paletteId,
            this.outputType,
            +this.radix,
            this.insertSize,
            this.useCrop ? this.crop : null
        );
        if (paletteId !== this.lastPalette) {
          var resultImageDiv = this.$refs.resultImage;
          this.converter.drawResultImage(resultImageDiv, paletteId);
          this.lastPalette = paletteId;
        }
      },

      resetCrop: function() {
        this.crop = {
          x: 0,
          y: 0,
          width: this.maxWidth,
          height: this.maxHeight
        };
        localStorage.removeItem(STORAGE_KEY_CROP);
      },

      copyResult: function() {
        this.$refs.result.select();
        document.execCommand('copy');
      }
    }
  });

  /**
   * Получение конвертера из выбранного файла, принимает дополнительно элемент img,
   * в котором отображаем выбранную картинку.
   * @returns {Promise<{converter: *, error: *}>}
   */
  function getConverterFromFile(file, img) {
    return readFileAsDataURL(file).then(function(dataURL) {
      return setImageSrc(img, dataURL);
    }).then(function() {
      var error, converter;
      var imageWidth = img.width;
      var imageHeight = img.height;
      if (!imageWidth || !imageHeight) {
        error = 'Некорректное изображение';
      } else if (imageWidth > 256 || imageHeight > 256) {
        error = 'Изображение больше, чем 256x256';
      } else {
        var imageData = getImageData(img, imageWidth, imageHeight);
        converter = initConverter(imageData, imageWidth, imageHeight, getFileName(file));
      }
      return {error: error, converter: converter};
    });

    function readFileAsDataURL(file) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.readAsDataURL(file);
      });
    }

    function setImageSrc(img, url) {
      return new Promise(function(resolve, reject) {
        img.onload = function() {
          resolve(img);
        };
        img.src = url;
      });
    }

    /**
     * Побеждаем глюк файловой системы macos с буквами Й и Ё
     */
    function getFileName(file) {
      return file.name.replace(/И\u0306/g, 'Й').
          replace(/и\u0306/g, 'й').
          replace(/Е\u0308/g, 'Ё').
          replace(/е\u0308/g, 'ё');
    }

    /**
     * Получение массива цветов точек изображений, по 4 элемента на точку
     * в формате [r0, g0, b0, a0, r1, ...]
     * @returns {Uint8ClampedArray}
     */
    function getImageData(img, width, height) {
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      return ctx.getImageData(0, 0, width, height).data;
    }
  }

  /**
   * Получение объекта конвертера из данных по картинке
   * @returns {{getMatchedPalettes: *, drawResultImage: *, getSourceText: *}}
   */
  function initConverter(imageData, width, height, fileName) {
    var DIGITS_COUNT = {};
    DIGITS_COUNT[OUTPUT_BYTE] = {
      2: 8,
      8: 3,
      10: 3,
      16: 2
    };
    DIGITS_COUNT[OUTPUT_WORD] = {
      2: 16,
      8: 6,
      10: 5,
      16: 4
    };

    var colorsConfig = getColorsConfig();
    var colorToPalettes = colorsConfig.colorToPalettes;
    var colorToIndexByPallette = colorsConfig.colorToIndexByPallette;
    var colorComponentsConfig = colorsConfig.colorToComponentsWithDelta;

    var pixels = _getPixels(imageData);
    imageData = undefined;

    function getMatchedPalettes() {
      var topColors = _getTopColors(3);
      var stat = topColors.reduce(function(acc, color) {
        return acc.concat(colorToPalettes[color]);
      }, []).reduce(function(acc, pal) {
        if (!(pal in acc)) acc[pal] = 0;
        acc[pal]++;
        return acc;
      }, {});
      var max = Math.max.apply(Math, Object.keys(stat).map(function(pal) {
        return stat[pal];
      }));
      var palettes = Object.keys(stat).reduce(function(acc, pal) {
        var count = stat[pal];
        if (count === max) {
          acc.push((pal.length < 2 ? '0' : '') + pal);
        }
        return acc;
      }, []);
      return palettes.sort();
    }

    function getSourceText(paletteId, outputType, radix, insertSize, crop) {
      var area;
      if (crop) {
        area = {
          yBegin: crop.y,
          yEnd: Math.min(crop.y + crop.height, height),
          xBegin: crop.x * 4,
          xEnd: Math.min((crop.x + crop.width) * 4, width),
        };
      } else {
        area = {
          yBegin: 0,
          yEnd: height,
          xBegin: 0,
          xEnd: width,
        };
      }
      var colorToIndex = colorToIndexByPallette[paletteId];
      var bytes = _getBytesFromPixels(colorToIndex, area);
      var text = '\t; ' + fileName +
          (crop ? ' [' + crop.x + ',' + crop.y + '/' +
              crop.width + ',' + crop.height + ']' : '') + '\r\n' +
          _convertBytes(bytes, outputType, radix, insertSize, area);
      return text;
    }

    function drawResultImage(imageContainer, paletteId) {
      imageContainer.innerHTML = '';
      var canvas = document.createElement('canvas');
      var colorToIndex = colorToIndexByPallette[paletteId];
      canvas.width = width * PREVIEW_PIXEL_WIDTH;
      canvas.height = height * PREVIEW_PIXEL_HEIGHT;
      var ctx = canvas.getContext('2d');
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0,
          width * PREVIEW_PIXEL_WIDTH, height * PREVIEW_PIXEL_HEIGHT);
      var color, i = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          color = pixels[i++];
          if (color && (color in colorToIndex)) {
            ctx.fillStyle = '#' + color;
            ctx.fillRect(
                x * PREVIEW_PIXEL_WIDTH,
                y * PREVIEW_PIXEL_HEIGHT,
                PREVIEW_PIXEL_WIDTH,
                PREVIEW_PIXEL_HEIGHT
            );
          }
        }
      }
      imageContainer.appendChild(canvas);
    }

    function getSize() {
      return {width: width, height: height};
    }

    function _getPixels(imageData) {
      var colors = ['r', 'g', 'b'];
      var pixels = [];
      var color, c, colorComponents;
      for (var i = 0; i < imageData.length; i++) {
        colorComponents = colors.reduce(function(acc, c) {
          acc[c] = imageData[i++];
          return acc;
        }, {});
        color = colors.reduce(function(acc, c) {
          var colorHex = colorComponents[c].toString(16);
          acc += (colorHex.length < 2 ? '0' : '') + colorHex;
          return acc;
        }, '');
        if (color === '000000') {
          color = null;
        } else if (!(color in colorComponentsConfig)) {
          color = _findColor(colorComponents);
        }
        pixels.push(color);
      }
      return pixels;
    }

    function _findColor(colorComponents) {
      var color = null, c;
      for (var clr in colorComponentsConfig) {
        c = colorComponentsConfig[clr];
        if (
            colorComponents.r >= c.rMin && colorComponents.r <= c.rMax &&
            colorComponents.g >= c.gMin && colorComponents.g <= c.gMax &&
            colorComponents.b >= c.bMin && colorComponents.b <= c.bMax
        ) {
          color = clr;
          break;
        }
      }
      return color;
    }

    function _getTopColors(topCount) {
      var stat = pixels.reduce(function(acc, color) {
        if (color) {
          if (!(color in acc)) {
            acc[color] = 0;
          }
          acc[color]++;
        }
        return acc;
      }, {});
      return Object.keys(stat).map(function(color) {
        return {color: color, count: stat[color]};
      }).sort(function(a, b) {
        return a.count - b.count;
      }).slice(0, topCount).map(function(item) {
        return item.color;
      });
    }

    function _getBytesFromPixels(colorToIndex, area) {
      var bytes = [];
      var color, byte, bitsPos;
      var i;

      for (var y = area.yBegin; y < area.yEnd; y++) {
        byte = bitsPos = 0;
        i = y * width + area.xBegin;
        for (var x = area.xBegin; x < area.xEnd; x++) {
          color = pixels[i++];
          if (color && (color in colorToIndex)) {
            byte |= colorToIndex[color] << bitsPos;
          }
          bitsPos += 2;
          if (bitsPos === 8) {
            bytes.push(byte);
            byte = bitsPos = 0;
          }
        }
        if (bitsPos) {
          bytes.push(byte);
        }
      }
      return bytes;
    }

    function _convertBytes(bytes, outputType, radix, insertSize, area) {
      var width = area.xEnd - area.xBegin;
      var height = area.yEnd - area.yBegin;
      var bytesPerLine = Math.ceil(width / 4);
      var textLines = [];
      if (insertSize) {
        var sizesLine = [
          outputType === OUTPUT_WORD ? Math.ceil(bytesPerLine / 2) : bytesPerLine,
          height
        ];
        textLines.push(_getValuesLine(sizesLine, OUTPUT_BYTE, radix));
      }
      for (var line = 0; line < height; line++) {
        var lineBytes = bytes.slice(line * bytesPerLine, (line + 1) * bytesPerLine);
        textLines.push(_getValuesLine(lineBytes, outputType, radix));
      }
      return textLines.map(function(line) {
        return '\t' + line;
      }).join('\r\n');
    }

    function _getValuesLine(lineBytes, outputType, radix) {
      var isWord = outputType === OUTPUT_WORD;
      var digits = DIGITS_COUNT[outputType][radix];
      var values = [];
      for (var i = 0; i < lineBytes.length; i++) {
        var value = lineBytes[i] + (isWord ? lineBytes[++i] << 8 : 0);
        var valueStr = value.toString(radix);
        for (var j = valueStr.length; j < digits; j++) {
          valueStr = '0' + valueStr;
        }
        if (radix === 2) {
          valueStr = '0b' + valueStr;
        } else if (radix === 16) {
          valueStr = '0x' + valueStr;
        } else if (radix === 10) {
          valueStr += '.';
        }
        values.push(valueStr);
      }
      return '.' + outputType + '\t' + values.join(',');
    }

    return {
      getMatchedPalettes: getMatchedPalettes,
      getSourceText: getSourceText,
      drawResultImage: drawResultImage,
      getSize: getSize
    };
  }

  function getColorsConfig() {
    var COLORS = ['r', 'g', 'b'];

    var colorToIndexByPallette = PALETTES.map(function(colors) {
      return colors.reduce(function(acc, color, index) {
        acc[color.toLowerCase()] = index + 1;
        return acc;
      }, {});
    });

    var colorToPalettes = colorToIndexByPallette.reduce(function(acc, colors, palId) {
      return Object.keys(colors).reduce(function(acc, color) {
        if (!(color in acc)) acc[color] = [];
        acc[color].push(palId);
        return acc;
      }, acc);
    }, {});

    var colorToComponentsWithDelta = Object.keys(colorToPalettes).reduce(function(acc, color) {
      var components = [];
      for (var i = 0; i < 6; i += 2) {
        components.push(parseInt(color.substr(i, 2), 16));
      }
      components = components.reduce(function(res, base, i) {
        var min = base - COLOR_DELTA;
        var max = base + COLOR_DELTA;
        res[COLORS[i] + 'Min'] = min < 0 ? 0 : min;
        res[COLORS[i] + 'Max'] = max > 255 ? 255 : max;
        return res;
      }, {});

      acc[color] = components;
      return acc;
    }, {});

    return {
      palettes: PALETTES,
      colorToIndexByPallette: colorToIndexByPallette,
      colorToPalettes: colorToPalettes,
      colorToComponentsWithDelta: colorToComponentsWithDelta
    };
  }
</script>
</body>
</html>